#' Evaluate predicted class probabilities over a validation set for a given score function.
#' 
#' @details Given a \code{datasetResample} object and a compatible 
#' \code{uniContValidation} prediction object it computes prediction scores
#' of some \code{type} for each model used in the validation step. 
#' 
#' @param pred_obj A \code{uniContValidation} object, usually generated
#'  from the \code{datasetResample} object with
#'  some set of predictive models through an interface function to 
#'  the \code{tgmUniCont} package.
#' @param resample_indexes A \code{datasetResample} object, usually
#'  generated by the \code{generateTestIndexes} function.
#' @param type Which type of score function should be used. 
#'  See \code{?computeUniContScore} for the updated list of score 
#'  functions available.
#' @param ignore_tag Before computing scores, we check to see if 
#'  \code{pred_obj} was indeed generated from the \code{resample_indexes}.
#'  In case of a mismatch an error is issued, unless \code{ignore_tag = FALSE},
#'  in which case just a warning is issued.
#' 
#' @return An S3 object of class \code{multiClassValidationScores}.
#' 
#' @export
evaluateProbClass.uniContValidation <- function(pred_obj, resample_indexes, type, 
                                                ignore_tag = FALSE, replicate_index = NULL, ...){
  
  resample_tag <- mcGet(resample_indexes, "tag")
  prediction_tag <- mcGet(pred_obj, "tag")
  
  checkTags(resample_tag = resample_tag, 
            prediction_tag = prediction_tag, 
            ignore_tag = ignore_tag)
  
  number_models <- mcGet(pred_obj, "number_models")
  scores_all <- list()
  
  weight_name <- mcGet(pred_obj, "weight_name")
  if (is.null(weight_name)){
    weight <- NULL
  } else {
    weight <- mcGet(resample_indexes, "dataset")
    weight <- weight[mcGet(resample_indexes, "validation", i = replicate_index), weight_name]
  }

  target_i <- mcGet(resample_indexes, "validation_target", i = replicate_index)
  
  for (i in 1:number_models){
    
    predictions_i <- mcGet(pred_obj, "pred", i)
    scores_all[[i]] <- computeUniContScore(prediction = predictions_i, target = target_i, type = type, weight = weight, ...)
    
  }
  
  ## The class multiClassValidationScores seems to be suited for 
  ## uniContValidation as well. Later change it for a more general name.
  result <- multiClassValidationScores(scores_list = scores_all, 
                                       resample_indexes = resample_indexes, 
                                       replicate_index = replicate_index, 
                                       score_type = type,
                                       tune_grid = mcGet(pred_obj, "tune_grid"))
  return(result)
  
}

#' Compute scores from univariate and continuous predictions.
#' 
#' @details Given a set of \code{prediction} and \code{target} values it will
#'   compute the score function for each prediction point. Possibly each prediction
#'   point can be associated with a \code{weight}
#'   
#' @param prediction Numeric vector with univariate predictions.
#' @param target Numeric vector with the observed values of the target variables.
#' @param type Which score function to use. See details.
#' @param weight Numeric vector with the weight given to each prediction point. 
#'  Default is NULL.
#' @param ... extra parameters used in a specific score function. Currently not in use.
#' 
#' @details Currently available score functions are 'negative_square_error'.
#'   
#' @return Numeric vector with length equal to the number of \code{prediction}
#' points containing the scores for each prediction point.
#' 
#' @export       
computeUniContScore <- function(prediction, target, type, weight = NULL, ...){
  
  if (type == "negative_square_error"){
    result <- computeNegativeSquareError(prediction = prediction, target = target, weight = weight)
    return(result)
  } else {
    stop("Invalid type.\n")
  }
  
}

#' Compute the negative of the square error of predictions
#' 
#' Compute the negative of the square error of predictions. The negative part
#' is to ensure that the higher the metric is the better.
#' 
#' @param prediction Numeric vector with univariate predictions.
#' @param target Numeric vector with the observed values of the target variables.
#' @param weight Numeric vector with the weight given to each prediction point. 
#'  Default is NULL.
computeNegativeSquareError <- function(prediction, target, weight = NULL){
  
  if (is.null(weight)){
    result <- as.numeric((prediction - target)^2)
    return(result)
  } else {
    result <- as.numeric(weight*((prediction - target)^2))
    return(result)
  }
  
}